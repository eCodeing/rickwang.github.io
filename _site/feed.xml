<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>奇怪的姿势又增加了~</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 26 Apr 2020 16:58:38 +0800</pubDate>
    <lastBuildDate>Sun, 26 Apr 2020 16:58:38 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>golang map</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#哈希结构&quot; id=&quot;markdown-toc-哈希结构&quot;&gt;哈希结构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#golang的map实现&quot; id=&quot;markdown-toc-golang的map实现&quot;&gt;golang的map实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;哈希结构&quot;&gt;哈希结构&lt;/h2&gt;

&lt;h2 id=&quot;golang的map实现&quot;&gt;golang的map实现&lt;/h2&gt;
</description>
        <pubDate>Sun, 26 Apr 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/back-end/golang-map/</link>
        <guid isPermaLink="true">http://localhost:4000/back-end/golang-map/</guid>
        
        <category>golang</category>
        
        <category>data-structure</category>
        
        
        <category>back-end</category>
        
      </item>
    
      <item>
        <title>shell</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#变量&quot; id=&quot;markdown-toc-变量&quot;&gt;变量&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#变量类型&quot; id=&quot;markdown-toc-变量类型&quot;&gt;变量类型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#特殊变量&quot; id=&quot;markdown-toc-特殊变量&quot;&gt;特殊变量&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#替换&quot; id=&quot;markdown-toc-替换&quot;&gt;替换&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#命令替换&quot; id=&quot;markdown-toc-命令替换&quot;&gt;命令替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#变量替换&quot; id=&quot;markdown-toc-变量替换&quot;&gt;变量替换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#运算符&quot; id=&quot;markdown-toc-运算符&quot;&gt;运算符&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#算术运算符&quot; id=&quot;markdown-toc-算术运算符&quot;&gt;算术运算符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#关系运算符&quot; id=&quot;markdown-toc-关系运算符&quot;&gt;关系运算符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#布尔运算符&quot; id=&quot;markdown-toc-布尔运算符&quot;&gt;布尔运算符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#字符串运算符&quot; id=&quot;markdown-toc-字符串运算符&quot;&gt;字符串运算符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#文件测试运算符&quot; id=&quot;markdown-toc-文件测试运算符&quot;&gt;文件测试运算符&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#注释&quot; id=&quot;markdown-toc-注释&quot;&gt;注释&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#字符串&quot; id=&quot;markdown-toc-字符串&quot;&gt;字符串&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#数组&quot; id=&quot;markdown-toc-数组&quot;&gt;数组&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#定义&quot; id=&quot;markdown-toc-定义&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#读取&quot; id=&quot;markdown-toc-读取&quot;&gt;读取&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#长度&quot; id=&quot;markdown-toc-长度&quot;&gt;长度&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#echo&quot; id=&quot;markdown-toc-echo&quot;&gt;echo&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#原样输出字符串&quot; id=&quot;markdown-toc-原样输出字符串&quot;&gt;原样输出字符串&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#显示命令执行结果&quot; id=&quot;markdown-toc-显示命令执行结果&quot;&gt;显示命令执行结果&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#printf&quot; id=&quot;markdown-toc-printf&quot;&gt;printf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#分支&quot; id=&quot;markdown-toc-分支&quot;&gt;分支&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#if&quot; id=&quot;markdown-toc-if&quot;&gt;if&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#if-else&quot; id=&quot;markdown-toc-if-else&quot;&gt;if else&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#if--elif--fi&quot; id=&quot;markdown-toc-if--elif--fi&quot;&gt;if  elif  fi&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#多分枝选择&quot; id=&quot;markdown-toc-多分枝选择&quot;&gt;多分枝选择&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#循环&quot; id=&quot;markdown-toc-循环&quot;&gt;循环&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#for&quot; id=&quot;markdown-toc-for&quot;&gt;for&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#while&quot; id=&quot;markdown-toc-while&quot;&gt;while&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#until&quot; id=&quot;markdown-toc-until&quot;&gt;until&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#跳出循环&quot; id=&quot;markdown-toc-跳出循环&quot;&gt;跳出循环&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#break&quot; id=&quot;markdown-toc-break&quot;&gt;break&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#continue&quot; id=&quot;markdown-toc-continue&quot;&gt;continue&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#函数&quot; id=&quot;markdown-toc-函数&quot;&gt;函数&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#定义-1&quot; id=&quot;markdown-toc-定义-1&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#嵌套&quot; id=&quot;markdown-toc-嵌套&quot;&gt;嵌套&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#删除&quot; id=&quot;markdown-toc-删除&quot;&gt;删除&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#参数&quot; id=&quot;markdown-toc-参数&quot;&gt;参数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#io重定向&quot; id=&quot;markdown-toc-io重定向&quot;&gt;IO重定向&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#here-document&quot; id=&quot;markdown-toc-here-document&quot;&gt;Here Document&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#devnull&quot; id=&quot;markdown-toc-devnull&quot;&gt;/dev/null&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#文件包含&quot; id=&quot;markdown-toc-文件包含&quot;&gt;文件包含&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Shell有两种执行命令的方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几种shell：
bash（默认），sh，ash，csh，ksh&lt;/p&gt;

&lt;h1 id=&quot;变量&quot;&gt;变量&lt;/h1&gt;

&lt;p&gt;变量名和等号之间不能有空格&lt;/p&gt;

&lt;p&gt;首个字符必须为字母（a-z，A-Z）。&lt;/p&gt;

&lt;p&gt;中间不能有空格，可以使用下划线（_）。&lt;/p&gt;

&lt;p&gt;不能使用标点符号。&lt;/p&gt;

&lt;p&gt;不能使用bash里的关键字（可用help命令查看保留关键字）。&lt;/p&gt;

&lt;p&gt;使用变量，只要在变量名前面加美元符号（&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;）即可&lt;/p&gt;

&lt;p&gt;加&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;是为了帮助解释器识别变量的边界，推荐给所有变量引用加上花括号&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt; 命令可以将变量定义为&lt;code class=&quot;highlighter-rouge&quot;&gt;只读&lt;/code&gt;变量，只读变量的值不能被改变。&lt;/p&gt;

&lt;p&gt;定义变量：&lt;code class=&quot;highlighter-rouge&quot;&gt;variableName=&quot;value&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;unset&lt;/code&gt; 命令可以&lt;code class=&quot;highlighter-rouge&quot;&gt;删除&lt;/code&gt;变量&lt;/p&gt;

&lt;h2 id=&quot;变量类型&quot;&gt;变量类型&lt;/h2&gt;

&lt;p&gt;运行shell时，会同时存在三种变量：&lt;/p&gt;

&lt;p&gt;1) 局部变量&lt;/p&gt;

&lt;p&gt;局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。&lt;/p&gt;

&lt;p&gt;2) 环境变量&lt;/p&gt;

&lt;p&gt;所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。&lt;/p&gt;

&lt;p&gt;3) shell变量&lt;/p&gt;

&lt;p&gt;shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行&lt;/p&gt;

&lt;h2 id=&quot;特殊变量&quot;&gt;特殊变量&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$0&lt;/code&gt;	当前脚本的文件名&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$n&lt;/code&gt;	传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt;，第二个参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$# &lt;/code&gt;	传递给脚本或函数的参数个数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;	传递给脚本或函数的所有参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;	传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 &lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 稍有不同，下面将会讲到。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt;	上个命令的退出状态，或函数的返回值，大部分命令执行成功会返回 0，失败返回 1；不过，也有一些命令返回其他值，表示不同类型的错误。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt;	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 的区别：&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt;” “&lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt;” … “&lt;code class=&quot;highlighter-rouge&quot;&gt;$n&lt;/code&gt;” 的形式输出所有参数；但是当它们被双引号(“ “)包含时，”&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;” 会将所有的参数作为一个整体，以”&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt; … &lt;code class=&quot;highlighter-rouge&quot;&gt;$n&lt;/code&gt;“的形式输出所有参数；”&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;” 会将各个参数分开，以”&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt;” “&lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt;” … “&lt;code class=&quot;highlighter-rouge&quot;&gt;$n&lt;/code&gt;” 的形式输出所有参数。&lt;/p&gt;

&lt;h1 id=&quot;替换&quot;&gt;替换&lt;/h1&gt;

&lt;p&gt;转义字符&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;	反斜杠&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;	警报，响铃&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;	退格（删除键）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;	换页(FF)，将当前位置移到下页开头&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt;	换行&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\r&lt;/code&gt;	回车&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;	水平制表符（tab键）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\v&lt;/code&gt;	垂直制表符&lt;/p&gt;

&lt;p&gt;-e 表示对转义字符进行替换&lt;/p&gt;

&lt;p&gt;-E 选项禁止转义&lt;/p&gt;

&lt;p&gt;-n 选项可以禁止插入换行符&lt;/p&gt;

&lt;h2 id=&quot;命令替换&quot;&gt;命令替换&lt;/h2&gt;

&lt;p&gt;命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash

DATE=`date`
echo &quot;Date is $DATE&quot;

USERS=`who | wc -l`
echo &quot;Logged in user are $USERS&quot;

UP=`date ; uptime`
echo &quot;Uptime is $UP&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;变量替换&quot;&gt;变量替换&lt;/h2&gt;

&lt;p&gt;变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${var}&lt;/code&gt; 变量本来的值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${var:-word}&lt;/code&gt;	如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${var:=word}&lt;/code&gt;	如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${var:?message}&lt;/code&gt;	如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${var:+word}&lt;/code&gt;	如果变量 var 被定义，那么返回 word，但不改变 var 的值。&lt;/p&gt;

&lt;h1 id=&quot;运算符&quot;&gt;运算符&lt;/h1&gt;

&lt;p&gt;原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。&lt;/p&gt;

&lt;p&gt;expr 是一款表达式计算工具，使用它能完成表达式的求值操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash

val=`expr 2 + 2`
echo &quot;Total value : $val&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;算术运算符&quot;&gt;算术运算符&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;	加法	&lt;code class=&quot;highlighter-rouge&quot;&gt;expr $a + $b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;	减法	&lt;code class=&quot;highlighter-rouge&quot;&gt;expr $a - $b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;	乘法	&lt;code class=&quot;highlighter-rouge&quot;&gt;expr $a \* $b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;	除法	&lt;code class=&quot;highlighter-rouge&quot;&gt;expr $b / $a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;	取余	&lt;code class=&quot;highlighter-rouge&quot;&gt;expr $b % $a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;	赋值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;	相等。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;	不相等。&lt;/p&gt;

&lt;p&gt;乘号(*)前边必须加反斜杠()才能实现乘法运算&lt;/p&gt;

&lt;h2 id=&quot;关系运算符&quot;&gt;关系运算符&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-eq&lt;/code&gt;	检测两个数是否相等，相等返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ne&lt;/code&gt;	检测两个数是否相等，不相等返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-gt&lt;/code&gt;	检测左边的数是否大于右边的，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-lt&lt;/code&gt;	检测左边的数是否小于右边的，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ge&lt;/code&gt;	检测左边的数是否大等于右边的，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-le&lt;/code&gt;	检测左边的数是否小于等于右边的，如果是，则返回 true。&lt;/p&gt;

&lt;h2 id=&quot;布尔运算符&quot;&gt;布尔运算符&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;	非运算，表达式为 true 则返回 false，否则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o&lt;/code&gt;	或运算，有一个表达式为 true 则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;	与运算，两个表达式都为 true 才返回 true。&lt;/p&gt;

&lt;h2 id=&quot;字符串运算符&quot;&gt;字符串运算符&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;	检测两个字符串是否相等，相等返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;	检测两个字符串是否相等，不相等返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-z str&lt;/code&gt;	检测字符串长度是否为0，为0返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n str&lt;/code&gt;	检测字符串长度是否不为0，不为0返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;	检测字符串是否为空，不为空返回 true。&lt;/p&gt;

&lt;h2 id=&quot;文件测试运算符&quot;&gt;文件测试运算符&lt;/h2&gt;

&lt;p&gt;文件测试运算符用于检测 Unix 文件的各种属性。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b file&lt;/code&gt;	检测文件是否是块设备文件，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c file&lt;/code&gt;	检测文件是否是字符设备文件，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d file&lt;/code&gt;	检测文件是否是目录，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f file&lt;/code&gt;	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-g file&lt;/code&gt;	检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-k file&lt;/code&gt;	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p file&lt;/code&gt;	检测文件是否是具名管道，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-u file&lt;/code&gt;	检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r file&lt;/code&gt;	检测文件是否可读，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-w file&lt;/code&gt;	检测文件是否可写，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-x file&lt;/code&gt;	检测文件是否可执行，如果是，则返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s file&lt;/code&gt;	检测文件是否为空（文件大小是否大于0），不为空返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e file&lt;/code&gt;	检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/p&gt;

&lt;h1 id=&quot;注释&quot;&gt;注释&lt;/h1&gt;

&lt;p&gt;以“# ”开头的行就是注释，会被解释器忽略。&lt;/p&gt;

&lt;p&gt;sh里没有多行注释，只能每一行加一个# 号。可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。&lt;/p&gt;

&lt;h1 id=&quot;字符串&quot;&gt;字符串&lt;/h1&gt;

&lt;p&gt;单引号字符串的限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单引号字串中不能出现单引号（对单引号使用转义符后也不行）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;双引号的优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;双引号里可以有变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;双引号里可以出现转义字符&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;拼接字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;your_name=&quot;qinjx&quot;
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;

echo $greeting $greeting_1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;获取字符串长度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string=&quot;abcd&quot;
echo ${# string} # 输出 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;提取子字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string=&quot;alibaba is a great company&quot;
echo ${string:1:4} # 输出liba
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查找子字符串&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr index String1 String2&lt;/code&gt; 返回 String1 中包含 String2 中任意字符的第一个位置。（从1开始数）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string=&quot;alibaba is a great company&quot;
echo `expr index &quot;$string&quot; is`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;数组&quot;&gt;数组&lt;/h1&gt;

&lt;p&gt;bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。&lt;/p&gt;

&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

&lt;p&gt;在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：array_name=(value1 … valuen)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array_name=(value0 value1 value2 value3)

array_name=(
value0
value1
value2
value3
)

array_name[0]=value0
array_name[1]=value1
array_name[2]=value2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;读取&quot;&gt;读取&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;valuen=${array_name[2]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 可以获取数组中的所有元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;${array_name[*]}
${array_name[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;长度&quot;&gt;长度&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#   取得数组元素的个数
length=${# array_name[@]}
#   或者
length=${# array_name[*]}
#   取得数组单个元素的长度
lengthn=${# array_name[n]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;echo&quot;&gt;echo&lt;/h1&gt;

&lt;p&gt;echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 不要在最后自动换行&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般&lt;/p&gt;

&lt;p&gt;文字输出：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt; 发出警告声；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt; 删除前一个字符；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\c&lt;/code&gt; 最后不加上换行符号；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt; 换行但光标仍旧停留在原来的位置；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; 换行且光标移至行首；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\r&lt;/code&gt; 光标移至行首，但不换行；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt; 插入tab；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\v&lt;/code&gt; 与\f相同；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt; 插入\字符；&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\nnn&lt;/code&gt; 插入nnn（八进制）所代表的ASCII字符；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;–help&lt;/code&gt; 显示帮助&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;–version&lt;/code&gt; 显示版本信息&lt;/p&gt;

&lt;h2 id=&quot;原样输出字符串&quot;&gt;原样输出字符串&lt;/h2&gt;

&lt;p&gt;若需要原样输出字符串（不进行转义），请使用单引号&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo '$name\&quot;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;显示命令执行结果&quot;&gt;显示命令执行结果&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo `date`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;printf&quot;&gt;printf&lt;/h1&gt;

&lt;p&gt;printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。&lt;/p&gt;

&lt;p&gt;注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。&lt;/p&gt;

&lt;p&gt;printf 不像 echo 那样会自动换行，必须显式添加换行符(\n)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$printf &quot;Hello, Shell\n&quot;
Hello, Shell
$

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;printf 命令的语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf  format-string  [arguments...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;format-string 为格式控制字符串，arguments 为参数列表。&lt;/p&gt;

&lt;p&gt;这里仅说明与C语言printf()函数的不同：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;printf 命令不用加括号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;format-string 可以没有引号，但最好加上，单引号双引号均可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;arguments 使用空格分隔，不用逗号。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，根据POSIX标准，浮点格式%e、%E、%f、%g与%G是“不需要被支持”。这是因为awk支持浮点预算，且有它自己的printf语句。这样Shell程序中需要将浮点数值进行格式化的打印时，可使用小型的awk程序实现。然而，内建于bash、ksh93和zsh中的printf命令都支持浮点格式。&lt;/p&gt;

&lt;h1 id=&quot;分支&quot;&gt;分支&lt;/h1&gt;

&lt;p&gt;Shell 有三种 if … else 语句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;if … fi 语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;if … else … fi 语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;if … elif … else … fi 语句。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写，后面也会遇见。
注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。&lt;/p&gt;

&lt;h2 id=&quot;if&quot;&gt;if&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ expression ]
then
   statements
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;if-else&quot;&gt;if else&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ expression ]
then
   Statements
else
   Statements
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;if--elif--fi&quot;&gt;if  elif  fi&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ expression 1 ]
then
   Statements
elif [ expression 2 ]
then
   Statements
elif [ expression 3 ]
then
   Statements
else
   Statements
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;if … else 语句也可以写成一行，以命令的方式来运行，经常与 test 命令结合使用
&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; 命令用于检查某个条件是否成立，与方括号([ ])类似。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if test $[2*3] -eq $[1+5]; then echo 'The two numbers are equal!'; fi;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;多分枝选择&quot;&gt;多分枝选择&lt;/h1&gt;

&lt;p&gt;case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。
case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case 值 in
模式1)
    command1
    command2
    command3
    ;;
模式2)
    command1
    command2
    command3
    ;;
*)
    command1
    command2
    command3
    ;;
esac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;取值后面必须为关键字 &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;每一模式必须以&lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;结束&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;;;&lt;/code&gt; 与其他语言中的 break 类似&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash

option=&quot;${1}&quot;
case ${option} in
   -f) FILE=&quot;${2}&quot;
      echo &quot;File name is $FILE&quot;
      ;;
   -d) DIR=&quot;${2}&quot;
      echo &quot;Dir name is $DIR&quot;
      ;;
   *) 
      echo &quot;`basename ${0}`:usage: [-f file] | [-d directory]&quot;
      exit 1 #  Command to come out of the program with status 1
      ;;
esac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;循环&quot;&gt;循环&lt;/h1&gt;

&lt;h2 id=&quot;for&quot;&gt;for&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for 变量 in 列表
do
    command1
    command2
    ...
    commandN
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash

for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash

for FILE in $HOME/.bash*
do
   echo $FILE
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;while&quot;&gt;while&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while command
do
   statements
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;COUNTER=0
while [ $COUNTER -lt 5 ]
do
    COUNTER=`expr $COUNTER+1`
    echo $COUNTER
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;while循环可用于读取键盘信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo 'type &amp;lt;CTRL-D&amp;gt; to terminate'
echo -n 'enter your most liked film: '
while read FILM
do
    echo &quot;Yeah! great film the $FILM&quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;until&quot;&gt;until&lt;/h2&gt;

&lt;p&gt;until 循环执行一系列命令直至条件为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; 时&lt;code class=&quot;highlighter-rouge&quot;&gt;停止&lt;/code&gt;。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;until command
do
   statements
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;跳出循环&quot;&gt;跳出循环&lt;/h2&gt;

&lt;h3 id=&quot;break&quot;&gt;break&lt;/h3&gt;

&lt;p&gt;break将终止循环体中的后续操作&lt;/p&gt;

&lt;p&gt;在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环&lt;code class=&quot;highlighter-rouge&quot;&gt;break n&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;continue&quot;&gt;continue&lt;/h3&gt;

&lt;p&gt;continue跳出当次循环&lt;/p&gt;

&lt;p&gt;同样，continue 后面也可以跟一个数字，表示跳出第几层循环&lt;code class=&quot;highlighter-rouge&quot;&gt;continue n&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数&quot;&gt;函数&lt;/h1&gt;

&lt;h2 id=&quot;定义-1&quot;&gt;定义&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function_name () {
    list of commands
    [ return value ]
}

#  可以加上function 关键字
function function_name () {
    list of commands
    [ return value ]
}
#  函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。&lt;/p&gt;

&lt;p&gt;如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash
funWithReturn(){
    echo &quot;The function is to get the sum of two numbers...&quot;
    echo -n &quot;Input first number: &quot;
    read aNum
    echo -n &quot;Input another number: &quot;
    read anotherNum
    echo &quot;The two numbers are $aNum and $anotherNum !&quot;
    return $(($aNum+$anotherNum)) 
    # 两组括号的意思是做算术运算，如果不这么写直接写$a+$b的话，是按字符串理解的，就是25+50这个字符串
}
funWithReturn
#   Capture value returnd by last command
ret=$?
echo &quot;The sum of two numbers is $ret !&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用函数只需要给出函数名，不需要加括号。&lt;/p&gt;

&lt;p&gt;函数返回值在调用该函数后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt; 来获得。&lt;/p&gt;

&lt;h2 id=&quot;嵌套&quot;&gt;嵌套&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash

#   Calling one function from another
number_one () {
   echo &quot;Url_1 is http://see.xidian.edu.cn/cpp/shell/&quot;
   number_two
}

number_two () {
   echo &quot;Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/&quot;
}

number_one
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unset .f function_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;

&lt;p&gt;在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;$n&lt;/code&gt; 的形式来获取参数的值，例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt;表示第一个参数，&lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt;表示第二个参数…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash
funWithParam(){
    echo &quot;The value of the first parameter is $1 !&quot;
    echo &quot;The value of the second parameter is $2 !&quot;
    echo &quot;The value of the tenth parameter is $10 !&quot;
    echo &quot;The value of the tenth parameter is ${10} !&quot;
    echo &quot;The value of the eleventh parameter is ${11} !&quot;
    echo &quot;The amount of the parameters is $#  !&quot;  #  参数个数
    echo &quot;The string of the parameters is $* !&quot;  #  传递给函数的所有参数
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;$10&lt;/code&gt; 不能获取第十个参数，获取第十个参数需要&lt;code class=&quot;highlighter-rouge&quot;&gt;${10}&lt;/code&gt;。当n&amp;gt;=10时，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;${n}&lt;/code&gt;来获取参数。&lt;/p&gt;

&lt;p&gt;特殊参数&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$# &lt;/code&gt;	传递给函数的参数个数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;	显示所有传递给函数的参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;	与&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;相同，但是略有区别，请查看Shell特殊变量。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt;	函数的返回值。&lt;/p&gt;

&lt;h1 id=&quot;io重定向&quot;&gt;IO重定向&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;command &amp;gt; file
command &amp;lt; file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;标准输入文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;)：stdin的文件描述符为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，Unix程序默认从stdin读取数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标准输出文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;)：stdout 的文件描述符为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;，Unix程序默认向stdout输出数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标准错误文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;)：stderr的文件描述符为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;，Unix程序会向stderr流中写入错误信息。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stderr 重定向到 file&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; command 2 &amp;gt; file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将 stdout 和 stderr 合并后重定向到 file&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;command &amp;gt; file 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认情况下，command &amp;gt; file 将 stdout 重定向到 file，command &amp;lt; file 将stdin 重定向到 file。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;gt; file&lt;/code&gt;	将输出重定向到 file。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;lt; file&lt;/code&gt;	将输入重定向到 file。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;gt;&amp;gt; file&lt;/code&gt; 	将输出以追加的方式重定向到 file。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;gt; file&lt;/code&gt;	将文件描述符为 n 的文件重定向到 file。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;gt;&amp;gt; file&lt;/code&gt;	将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;gt;&amp;amp; m&lt;/code&gt;	将输出文件 m 和 n 合并。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;lt;&amp;amp; m&lt;/code&gt;	将输入文件 m 和 n 合并。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt; tag&lt;/code&gt;	将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/p&gt;

&lt;h2 id=&quot;here-document&quot;&gt;Here Document&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;command &amp;lt;&amp;lt; delimiter
    document
delimiter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。
注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开始的delimiter前后的空格会被忽略掉。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;devnull&quot;&gt;/dev/null&lt;/h2&gt;

&lt;p&gt;/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。
屏蔽 stdout 和 stderr&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;command &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;文件包含&quot;&gt;文件包含&lt;/h1&gt;

&lt;p&gt;Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;. filename
#  或
source filename
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格&lt;/p&gt;

&lt;p&gt;脚本 subscript.sh&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;url=&quot;http://see.xidian.edu.cn/cpp/view/2738.html&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;引入当前目录下的subscript.sh脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#  !/bin/bash
. ./subscript.sh
echo $url
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 22 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linux/linux-shell/</link>
        <guid isPermaLink="true">http://localhost:4000/linux/linux-shell/</guid>
        
        <category>shell</category>
        
        <category>Linux</category>
        
        <category>script</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>make</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#makefile-文件结构&quot; id=&quot;markdown-toc-makefile-文件结构&quot;&gt;Makefile 文件结构&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#目标target&quot; id=&quot;markdown-toc-目标target&quot;&gt;目标（target）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#前置条件prerequisites&quot; id=&quot;markdown-toc-前置条件prerequisites&quot;&gt;前置条件（prerequisites）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#命令commands&quot; id=&quot;markdown-toc-命令commands&quot;&gt;命令（commands）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#makefile-文件语法&quot; id=&quot;markdown-toc-makefile-文件语法&quot;&gt;Makefile 文件语法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#通配符&quot; id=&quot;markdown-toc-通配符&quot;&gt;通配符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#回声echoing&quot; id=&quot;markdown-toc-回声echoing&quot;&gt;回声（echoing）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#模式匹配&quot; id=&quot;markdown-toc-模式匹配&quot;&gt;模式匹配&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#变量和赋值符&quot; id=&quot;markdown-toc-变量和赋值符&quot;&gt;变量和赋值符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#内置变量implicit-variables&quot; id=&quot;markdown-toc-内置变量implicit-variables&quot;&gt;内置变量（Implicit Variables）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#自动变量automatic-variables&quot; id=&quot;markdown-toc-自动变量automatic-variables&quot;&gt;自动变量（Automatic Variables）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#判断与循环&quot; id=&quot;markdown-toc-判断与循环&quot;&gt;判断与循环&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#函数&quot; id=&quot;markdown-toc-函数&quot;&gt;函数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#实例&quot; id=&quot;markdown-toc-实例&quot;&gt;实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）&lt;/p&gt;

&lt;p&gt;指定规则进行编译，默认为当前目录下的Makefile文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make -f rules.txt
或者
make --file=rules.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;makefile-文件结构&quot;&gt;Makefile 文件结构&lt;/h1&gt;

&lt;p&gt;Makefile文件由一系列规则（rules）构成。每条规则的形式如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt; 
[tab]  &amp;lt;commands&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。&lt;/p&gt;

&lt;p&gt;“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。&lt;/p&gt;

&lt;h2 id=&quot;目标target&quot;&gt;目标（target）&lt;/h2&gt;

&lt;p&gt;一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。&lt;/p&gt;

&lt;p&gt;除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clean:
	rm *.o

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make  clean

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。&lt;/p&gt;

&lt;p&gt;为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.PHONY: clean
clean:
	rm *.o temp

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。&lt;/p&gt;

&lt;p&gt;如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;前置条件prerequisites&quot;&gt;前置条件（prerequisites）&lt;/h2&gt;

&lt;p&gt;前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result.txt: source.txt
	cp source.txt result.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果当前目录中，source.txt 已经&lt;strong&gt;存在&lt;/strong&gt;，那么make result.txt可以正常运行，否则必须再写一条规则，来生成 source.txt 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source.txt:
	echo &quot;this is the source&quot; &amp;gt; source.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还&lt;strong&gt;不存在&lt;/strong&gt;，每次调用make source.txt，它都会生成。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make result.txt
$ make result.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面命令连续执行两次make result.txt。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt &lt;strong&gt;没有变动&lt;/strong&gt;（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。&lt;/p&gt;

&lt;p&gt;如果需要生成多个文件，往往采用下面的写法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source: file1 file2 file3

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make source

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行make source命令后，就会一次性生成 file1，file2，file3 三个文件&lt;/p&gt;

&lt;h2 id=&quot;命令commands&quot;&gt;命令（commands）&lt;/h2&gt;

&lt;p&gt;命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。&lt;/p&gt;

&lt;p&gt;每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.RECIPEPREFIX = &amp;gt;
all:
&amp;gt; echo Hello, world

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码用.RECIPEPREFIX指定，大于号（&amp;gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。&lt;/p&gt;

&lt;p&gt;需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var-lost:
    export foo=bar
    echo &quot;foo=[$$foo]&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码执行后（make var-lost），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var-kept:
    export foo=bar; echo &quot;foo=[$$foo]&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另一个解决办法是在换行符前加反斜杠转义。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var-kept:
    export foo=bar; \
    echo &quot;foo=[$$foo]&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一个方法是加上.ONESHELL:命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.ONESHELL:
var-kept:
    export foo=bar; 
    echo &quot;foo=[$$foo]&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;makefile-文件语法&quot;&gt;Makefile 文件语法&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;# &lt;/code&gt;号注释&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;通配符&quot;&gt;通配符&lt;/h2&gt;

&lt;p&gt;通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。&lt;/p&gt;

&lt;h2 id=&quot;回声echoing&quot;&gt;回声（echoing）&lt;/h2&gt;

&lt;p&gt;正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。&lt;/p&gt;

&lt;p&gt;在命令的前面加上@，就可以关闭回声。&lt;/p&gt;

&lt;h2 id=&quot;模式匹配&quot;&gt;模式匹配&lt;/h2&gt;

&lt;p&gt;Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%.o: %.c

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等同于下面的写法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f1.o: f1.c
f2.o: f2.c

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;待验证&lt;/p&gt;

  &lt;p&gt;关于模式匹配有个误解区，%.o:%.c并不是直接去匹配文件目录里的文件,而是匹配上下文的东西:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%.o:%.c&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc main.c -o main.o&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main.o:main.c&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;当我们make的时候 会执行 gcc main.c -o main.o&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;变量和赋值符&quot;&gt;变量和赋值符&lt;/h2&gt;

&lt;p&gt;Makefile 允许使用等号自定义变量。&lt;/p&gt;

&lt;p&gt;调用时，变量需要放在 $( ) 之中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;txt = Hello World
test:
    @echo $(txt)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test:
    @echo $$HOME

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有时，变量的值可能指向另一个变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v1 = $(v2)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（&lt;strong&gt;静态扩展&lt;/strong&gt;），还是在运行时扩展（&lt;strong&gt;动态扩展&lt;/strong&gt;）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。&lt;/p&gt;

&lt;p&gt;为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看&lt;a href=&quot;http://stackoverflow.com/questions/448910/makefile-variable-assignment&quot;&gt;StackOverflow&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VARIABLE = value
#  在执行时扩展，允许递归扩展。

VARIABLE := value
#  在定义时扩展。

VARIABLE ?= value
#  只有在该变量为空时才设置值。

VARIABLE += value
#  将值追加到变量的尾端。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;内置变量implicit-variables&quot;&gt;内置变量（Implicit Variables）&lt;/h2&gt;

&lt;p&gt;Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见&lt;a href=&quot;https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html&quot;&gt;手册&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;output:
    $(CC) -o output input.c

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;自动变量automatic-variables&quot;&gt;自动变量（Automatic Variables）&lt;/h2&gt;

&lt;p&gt;（1）&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;指代当前目标，就是Make命令当前构建的那个目标。比如，make foo的 &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 就指代foo。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.txt b.txt: 
    touch $@

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;等同于下面的写法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.txt:
    touch a.txt
b.txt:
    touch b.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（2）&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt; 就指代p1。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.txt: b.txt c.txt
    cp $&amp;lt; $@ 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等同于下面的写法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.txt: b.txt c.txt
    cp b.txt a.txt 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（3）&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt; 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt;就指代p2。&lt;/p&gt;

&lt;p&gt;（4）&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt; 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt; 就指代 p1 p2 。&lt;/p&gt;

&lt;p&gt;（5）&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 就表示 f1。&lt;/p&gt;

&lt;p&gt;（6）&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@D)&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(@F)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@D) &lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt; $(@F) &lt;/code&gt;分别指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 的目录名和文件名。比如，&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;是 src/input.c，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@D)&lt;/code&gt; 的值为 src ，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@F) &lt;/code&gt;的值为 input.c。&lt;/p&gt;

&lt;p&gt;（7）&lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;D)&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;F)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;D) &lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt; $(&amp;lt;F) &lt;/code&gt;分别指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt; &lt;/code&gt;的目录名和文件名。&lt;/p&gt;

&lt;p&gt;所有的自动变量清单，请看&lt;a href=&quot;https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html&quot;&gt;手册&lt;/a&gt;。下面是自动变量的一个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dest/%.txt: src/%.txt
    @[ -d dest ] || mkdir dest
    cp $&amp;lt; $@

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt; 指代前置文件（src/%.txt）， &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 指代目标文件（dest/%.txt）。&lt;/p&gt;

&lt;h2 id=&quot;判断与循环&quot;&gt;判断与循环&lt;/h2&gt;

&lt;p&gt;Makefile使用 Bash 语法，完成判断和循环。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifeq ($(CC),gcc)
  libs=$(libs_for_gcc)
else
  libs=$(normal_libs)
endif

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LIST = one two three
all:
    for i in $(LIST); do \
        echo $$i; \
    done
    
#  等同于

all:
    for i in one two three; do \
        echo $i; \
    done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;Makefile 还可以使用函数，格式如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(function arguments)
#  或者
${function arguments}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Makefile提供了许多&lt;a href=&quot;http://www.gnu.org/software/make/manual/html_node/Functions.html&quot;&gt;内置函数&lt;/a&gt;，可供调用。下面是几个常用的内置函数。&lt;/p&gt;

&lt;p&gt;（1）shell 函数&lt;/p&gt;

&lt;p&gt;shell 函数用来执行 shell 命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;srcfiles := $(shell echo src/{00..99}.txt)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（2）wildcard 函数&lt;/p&gt;

&lt;p&gt;wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;srcfiles := $(wildcard src/*.txt)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（3）subst 函数&lt;/p&gt;

&lt;p&gt;subst 函数用来文本替换，格式如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(subst from,to,text)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(subst ee,EE,feet on the street)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是一个稍微复杂的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comma:= ,
empty:=
#  space变量用两个空变量作为标识符，当中是一个空格
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
#  bar is now `a,b,c'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（4）patsubst函数&lt;/p&gt;

&lt;p&gt;patsubst 函数用于模式匹配的替换，格式如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(patsubst pattern,replacement,text)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(patsubst %.c,%.o,x.c.c bar.c)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（5）替换后缀名&lt;/p&gt;

&lt;p&gt;替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;min: $(OUTPUT:.js=.min.js)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。&lt;/p&gt;

&lt;h1 id=&quot;实例&quot;&gt;实例&lt;/h1&gt;

&lt;p&gt;（1）执行多个目标&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。&lt;/p&gt;

&lt;p&gt;（2）编译C语言项目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;edit : main.o kbd.o command.o display.o 
    cc -o edit main.o kbd.o command.o display.o

main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h
    cc -c display.c

clean :
     rm edit main.o kbd.o command.o display.o

.PHONY: edit clean

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 11 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linux/linux-make/</link>
        <guid isPermaLink="true">http://localhost:4000/linux/linux-make/</guid>
        
        <category>make</category>
        
        <category>Linux</category>
        
        <category>script</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
